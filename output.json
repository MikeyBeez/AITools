{
    "files": [
        {
            "path": "/Users/bard/Code/AITools/.envrc",
            "type": "unknown",
            "size": 26,
            "content": "layout anaconda AITools\n\n\n"
        },
        {
            "path": "/Users/bard/Code/AITools/README.md",
            "type": "md",
            "size": 2032,
            "content": "# AITools\n\nthis is a new project that isn't released yet -- so don't expect too much.\n\nAITools is a Python project that provides utilities and tools for working with AI agents.\n\n## Project Structure\n\n```\nAITools/\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 data/\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 modules/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 agents/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 data/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 models/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 input_util.py\n\u2514\u2500\u2500 tests/\n    \u2514\u2500\u2500 input_util_test.py\n```\n\n## Setup\n\n1. Clone the repository:\n\n   ```\n   git clone https://github.com/MikeyBeez/AITools.git\n   cd AITools\n   ```\n\n2. Create a conda environment:\n\n   ```\n   conda create --name aitools python=3.12\n   conda activate aitools\n   ```\n\n3. Install the required dependencies:\n\n   ```\n   conda install --file requirements.txt\n   ```\n\n   Note: If some packages are not available via conda, you may need to use pip:\n\n   ```\n   pip install -r requirements.txt\n   ```\n\n## Running the Application\n\nTo run the main application:\n\n```\npython main.py\n```\n\n## Running Tests\n\nTo run all tests:\n\n```\npython -m unittest discover tests\n```\n\nTo run a specific test file:\n\n```\npython -m unittest tests.input_util_test\n```\n\nOr, if you're in the `tests` directory:\n\n```\npython input_util_test.py\n```\n\n## Features\n\n- `input_util.py`: Provides an AI-friendly prompt function that supports asynchronous input and auto-completion.\n\n## Contributing\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/AmazingFeature`)\n3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)\n4. Push to the branch (`git push origin feature/AmazingFeature`)\n5. Open a Pull Request\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details.\n\n## Contact\n\nMikeyBeez\n\nProject Link: [https://github.com/MikeyBeez/AITools](https://github.com/MikeyBeez/AITools)\n"
        },
        {
            "path": "/Users/bard/Code/AITools/main.py",
            "type": "python",
            "size": 657,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [
                "Import(names=[alias(name='asyncio')])",
                "ImportFrom(module='modules.utils.input_util', names=[alias(name='ai_friendly_prompt')], level=0)",
                "ImportFrom(module='modules.utils.response', names=[alias(name='process_response')], level=0)",
                "ImportFrom(module='pathlib', names=[alias(name='Path')], level=0)",
                "Import(names=[alias(name='sys')])"
            ],
            "content": "import asyncio\nfrom modules.utils.input_util import ai_friendly_prompt\nfrom modules.utils.response import process_response\nfrom pathlib import Path\nimport sys\n\n# Add the project root to the Python path\nproject_root = Path(__file__).parent\nsys.path.append(str(project_root))\n\n\nasync def main():\n    while True:\n        prompt = await ai_friendly_prompt(\"Enter your prompt (or 'exit' to quit): \")\n        if prompt.lower() == \"exit\":\n            break\n        generate_and_print_response(prompt)\n        print()  # Add a newline after each response\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n    # print(sys.path)  # Commented out to reduce clutter\n"
        },
        {
            "path": "/Users/bard/Code/AITools/tests/input_util_test.py",
            "type": "python",
            "size": 3070,
            "docstring": null,
            "functions": [
                {
                    "name": "setUp",
                    "signature": "FunctionDef(name='setUp', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='new_event_loop', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='set_event_loop', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load())], keywords=[]))], decorator_list=[])",
                    "docstring": null
                },
                {
                    "name": "tearDown",
                    "signature": "FunctionDef(name='tearDown', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                    "docstring": null
                },
                {
                    "name": "test_ai_friendly_prompt_normal_input",
                    "signature": "FunctionDef(name='test_ai_friendly_prompt_normal_input', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='Future', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Load()), attr='set_result', ctx=Load()), args=[Constant(value='test input')], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='test input')], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='assert_called_once_with', ctx=Load()), args=[Constant(value='> ')], keywords=[keyword(arg='completer', value=Constant(value=None))]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                    "docstring": null
                },
                {
                    "name": "test_ai_friendly_prompt_with_completions",
                    "signature": "FunctionDef(name='test_ai_friendly_prompt_with_completions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='Future', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Load()), attr='set_result', ctx=Load()), args=[Constant(value='test input')], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='completions', ctx=Store())], value=List(elts=[Constant(value='help'), Constant(value='status'), Constant(value='exit')], ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[Constant(value='Agent> '), Name(id='completions', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='test input')], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='assert_called_once', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='args', ctx=Store()), Name(id='kwargs', ctx=Store())], ctx=Store())], value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='call_args', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Constant(value='Agent> ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsInstance', ctx=Load()), args=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='completer'), ctx=Load()), Name(id='WordCompleter', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                    "docstring": null
                },
                {
                    "name": "test_ai_friendly_prompt_keyboard_interrupt",
                    "signature": "FunctionDef(name='test_ai_friendly_prompt_keyboard_interrupt', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='side_effect', ctx=Store())], value=Call(func=Name(id='KeyboardInterrupt', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsNone', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                    "docstring": null
                },
                {
                    "name": "test_ai_friendly_prompt_eof_error",
                    "signature": "FunctionDef(name='test_ai_friendly_prompt_eof_error', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='side_effect', ctx=Store())], value=Call(func=Name(id='EOFError', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsNone', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                    "docstring": null
                }
            ],
            "classes": [
                {
                    "name": "TestAiFriendlyPrompt",
                    "docstring": null,
                    "methods": [
                        {
                            "name": "setUp",
                            "signature": "FunctionDef(name='setUp', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='new_event_loop', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='set_event_loop', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load())], keywords=[]))], decorator_list=[])",
                            "docstring": null
                        },
                        {
                            "name": "tearDown",
                            "signature": "FunctionDef(name='tearDown', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='close', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                            "docstring": null
                        },
                        {
                            "name": "test_ai_friendly_prompt_normal_input",
                            "signature": "FunctionDef(name='test_ai_friendly_prompt_normal_input', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='Future', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Load()), attr='set_result', ctx=Load()), args=[Constant(value='test input')], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='test input')], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='assert_called_once_with', ctx=Load()), args=[Constant(value='> ')], keywords=[keyword(arg='completer', value=Constant(value=None))]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                            "docstring": null
                        },
                        {
                            "name": "test_ai_friendly_prompt_with_completions",
                            "signature": "FunctionDef(name='test_ai_friendly_prompt_with_completions', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Store())], value=Call(func=Attribute(value=Name(id='asyncio', ctx=Load()), attr='Future', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='return_value', ctx=Load()), attr='set_result', ctx=Load()), args=[Constant(value='test input')], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='completions', ctx=Store())], value=List(elts=[Constant(value='help'), Constant(value='status'), Constant(value='exit')], ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[Constant(value='Agent> '), Name(id='completions', ctx=Load())], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Name(id='result', ctx=Load()), Constant(value='test input')], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='assert_called_once', ctx=Load()), args=[], keywords=[])), Assign(targets=[Tuple(elts=[Name(id='args', ctx=Store()), Name(id='kwargs', ctx=Store())], ctx=Store())], value=Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='call_args', ctx=Load())), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertEqual', ctx=Load()), args=[Subscript(value=Name(id='args', ctx=Load()), slice=Constant(value=0), ctx=Load()), Constant(value='Agent> ')], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsInstance', ctx=Load()), args=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='completer'), ctx=Load()), Name(id='WordCompleter', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                            "docstring": null
                        },
                        {
                            "name": "test_ai_friendly_prompt_keyboard_interrupt",
                            "signature": "FunctionDef(name='test_ai_friendly_prompt_keyboard_interrupt', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='side_effect', ctx=Store())], value=Call(func=Name(id='KeyboardInterrupt', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsNone', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                            "docstring": null
                        },
                        {
                            "name": "test_ai_friendly_prompt_eof_error",
                            "signature": "FunctionDef(name='test_ai_friendly_prompt_eof_error', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mock_prompt_session')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='mock_session', ctx=Store())], value=Call(func=Name(id='MagicMock', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Attribute(value=Name(id='mock_session', ctx=Load()), attr='prompt_async', ctx=Load()), attr='side_effect', ctx=Store())], value=Call(func=Name(id='EOFError', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='mock_prompt_session', ctx=Load()), attr='return_value', ctx=Store())], value=Name(id='mock_session', ctx=Load())), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='loop', ctx=Load()), attr='run_until_complete', ctx=Load()), args=[Call(func=Name(id='ai_friendly_prompt', ctx=Load()), args=[], keywords=[])], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='assertIsNone', ctx=Load()), args=[Name(id='result', ctx=Load())], keywords=[]))], decorator_list=[Call(func=Name(id='patch', ctx=Load()), args=[Constant(value='modules.utils.input_util.PromptSession')], keywords=[])])",
                            "docstring": null
                        }
                    ]
                }
            ],
            "imports": [
                "Import(names=[alias(name='unittest')])",
                "ImportFrom(module='unittest.mock', names=[alias(name='patch'), alias(name='MagicMock')], level=0)",
                "Import(names=[alias(name='asyncio')])",
                "Import(names=[alias(name='sys')])",
                "Import(names=[alias(name='os')])",
                "ImportFrom(module='modules.utils.input_util', names=[alias(name='ai_friendly_prompt')], level=0)",
                "ImportFrom(module='prompt_toolkit.completion', names=[alias(name='WordCompleter')], level=0)"
            ],
            "content": "import unittest\nfrom unittest.mock import patch, MagicMock\nimport asyncio\nimport sys\nimport os\n\n# Add the project root to the Python path\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nfrom modules.utils.input_util import ai_friendly_prompt\nfrom prompt_toolkit.completion import WordCompleter\n\nclass TestAiFriendlyPrompt(unittest.TestCase):\n    def setUp(self):\n        self.loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(self.loop)\n\n    def tearDown(self):\n        self.loop.close()\n\n    @patch('modules.utils.input_util.PromptSession')\n    def test_ai_friendly_prompt_normal_input(self, mock_prompt_session):\n        # Set up the mock\n        mock_session = MagicMock()\n        mock_session.prompt_async.return_value = asyncio.Future()\n        mock_session.prompt_async.return_value.set_result(\"test input\")\n        mock_prompt_session.return_value = mock_session\n\n        # Run the test\n        result = self.loop.run_until_complete(ai_friendly_prompt())\n        \n        # Assert the result\n        self.assertEqual(result, \"test input\")\n        mock_session.prompt_async.assert_called_once_with('> ', completer=None)\n\n    @patch('modules.utils.input_util.PromptSession')\n    def test_ai_friendly_prompt_with_completions(self, mock_prompt_session):\n        # Set up the mock\n        mock_session = MagicMock()\n        mock_session.prompt_async.return_value = asyncio.Future()\n        mock_session.prompt_async.return_value.set_result(\"test input\")\n        mock_prompt_session.return_value = mock_session\n\n        # Run the test\n        completions = ['help', 'status', 'exit']\n        result = self.loop.run_until_complete(ai_friendly_prompt('Agent> ', completions))\n        \n        # Assert the result\n        self.assertEqual(result, \"test input\")\n        mock_session.prompt_async.assert_called_once()\n        args, kwargs = mock_session.prompt_async.call_args\n        self.assertEqual(args[0], 'Agent> ')\n        self.assertIsInstance(kwargs['completer'], WordCompleter)\n\n    @patch('modules.utils.input_util.PromptSession')\n    def test_ai_friendly_prompt_keyboard_interrupt(self, mock_prompt_session):\n        # Set up the mock to raise KeyboardInterrupt\n        mock_session = MagicMock()\n        mock_session.prompt_async.side_effect = KeyboardInterrupt()\n        mock_prompt_session.return_value = mock_session\n\n        # Run the test\n        result = self.loop.run_until_complete(ai_friendly_prompt())\n        \n        # Assert the result\n        self.assertIsNone(result)\n\n    @patch('modules.utils.input_util.PromptSession')\n    def test_ai_friendly_prompt_eof_error(self, mock_prompt_session):\n        # Set up the mock to raise EOFError\n        mock_session = MagicMock()\n        mock_session.prompt_async.side_effect = EOFError()\n        mock_prompt_session.return_value = mock_session\n\n        # Run the test\n        result = self.loop.run_until_complete(ai_friendly_prompt())\n        \n        # Assert the result\n        self.assertIsNone(result)\n\nif __name__ == '__main__':\n    unittest.main()\n"
        },
        {
            "path": "/Users/bard/Code/AITools/tests/test.txt",
            "type": "txt",
            "size": 44,
            "content": "vim.opt.clipboard = \"unnamed,unnamedplus\"\n\n\n"
        },
        {
            "path": "/Users/bard/Code/AITools/modules/__init__.py",
            "type": "python",
            "size": 0,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [],
            "content": ""
        },
        {
            "path": "/Users/bard/Code/AITools/modules/agents/__init__.py",
            "type": "python",
            "size": 0,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [],
            "content": ""
        },
        {
            "path": "/Users/bard/Code/AITools/modules/utils/__init__.py",
            "type": "python",
            "size": 0,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [],
            "content": ""
        },
        {
            "path": "/Users/bard/Code/AITools/modules/utils/input_util.py",
            "type": "python",
            "size": 456,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [
                "ImportFrom(module='prompt_toolkit', names=[alias(name='PromptSession')], level=0)",
                "ImportFrom(module='prompt_toolkit.completion', names=[alias(name='WordCompleter')], level=0)"
            ],
            "content": "from prompt_toolkit import PromptSession\nfrom prompt_toolkit.completion import WordCompleter\n\n\nasync def ai_friendly_prompt(prompt=\"> \", completions=None):\n    session = PromptSession()\n\n    if completions:\n        completer = WordCompleter(completions)\n    else:\n        completer = None\n\n    try:\n        result = await session.prompt_async(prompt, completer=completer)\n        return result\n    except (KeyboardInterrupt, EOFError):\n        return None\n"
        },
        {
            "path": "/Users/bard/Code/AITools/modules/utils/response.py",
            "type": "python",
            "size": 1675,
            "docstring": null,
            "functions": [
                {
                    "name": "__init__",
                    "signature": "FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base_url'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='http://localhost:11434'), Constant(value='llama3.1:latest')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='base_url', ctx=Store())], value=Name(id='base_url', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Name(id='model', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Store())], value=Call(func=Name(id='WordAwareStreamPrinter', ctx=Load()), args=[], keywords=[keyword(arg='max_line_width', value=Constant(value=80))]))], decorator_list=[])",
                    "docstring": null
                },
                {
                    "name": "process_response",
                    "signature": "FunctionDef(name='process_response', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prompt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='url', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='base_url', ctx=Load()), conversion=-1), Constant(value='/api/generate')])), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Content-Type')], values=[Constant(value='application/json')])), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='prompt')], values=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), Name(id='prompt', ctx=Load())])), Try(body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='post', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='json', value=Name(id='data', ctx=Load())), keyword(arg='stream', value=Constant(value=True))]), optional_vars=Name(id='response', ctx=Store()))], body=[If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), ops=[Eq()], comparators=[Constant(value=200)]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='iter_lines', ctx=Load()), args=[], keywords=[]), body=[If(test=Name(id='line', ctx=Load()), body=[Assign(targets=[Name(id='json_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='response'), ops=[In()], comparators=[Name(id='json_response', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Load()), attr='add_text', ctx=Load()), args=[Subscript(value=Name(id='json_response', ctx=Load()), slice=Constant(value='response'), ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='json_response', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='done'), Constant(value=False)], keywords=[]), body=[Break()], orelse=[])], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error: Received status code '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1)])], keywords=[]))])])], handlers=[ExceptHandler(type=Attribute(value=Name(id='requests', ctx=Load()), attr='RequestException', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error connecting to Ollama: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Load()), attr='stop', ctx=Load()), args=[], keywords=[]))])], decorator_list=[])",
                    "docstring": null
                }
            ],
            "classes": [
                {
                    "name": "OllamaClient",
                    "docstring": null,
                    "methods": [
                        {
                            "name": "__init__",
                            "signature": "FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='base_url'), arg(arg='model')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='http://localhost:11434'), Constant(value='llama3.1:latest')]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='base_url', ctx=Store())], value=Name(id='base_url', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Name(id='model', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Store())], value=Call(func=Name(id='WordAwareStreamPrinter', ctx=Load()), args=[], keywords=[keyword(arg='max_line_width', value=Constant(value=80))]))], decorator_list=[])",
                            "docstring": null
                        },
                        {
                            "name": "process_response",
                            "signature": "FunctionDef(name='process_response', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prompt')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='url', ctx=Store())], value=JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='base_url', ctx=Load()), conversion=-1), Constant(value='/api/generate')])), Assign(targets=[Name(id='headers', ctx=Store())], value=Dict(keys=[Constant(value='Content-Type')], values=[Constant(value='application/json')])), Assign(targets=[Name(id='data', ctx=Store())], value=Dict(keys=[Constant(value='model'), Constant(value='prompt')], values=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), Name(id='prompt', ctx=Load())])), Try(body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Name(id='requests', ctx=Load()), attr='post', ctx=Load()), args=[Name(id='url', ctx=Load())], keywords=[keyword(arg='headers', value=Name(id='headers', ctx=Load())), keyword(arg='json', value=Name(id='data', ctx=Load())), keyword(arg='stream', value=Constant(value=True))]), optional_vars=Name(id='response', ctx=Store()))], body=[If(test=Compare(left=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), ops=[Eq()], comparators=[Constant(value=200)]), body=[For(target=Name(id='line', ctx=Store()), iter=Call(func=Attribute(value=Name(id='response', ctx=Load()), attr='iter_lines', ctx=Load()), args=[], keywords=[]), body=[If(test=Name(id='line', ctx=Load()), body=[Assign(targets=[Name(id='json_response', ctx=Store())], value=Call(func=Attribute(value=Name(id='json', ctx=Load()), attr='loads', ctx=Load()), args=[Name(id='line', ctx=Load())], keywords=[])), If(test=Compare(left=Constant(value='response'), ops=[In()], comparators=[Name(id='json_response', ctx=Load())]), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Load()), attr='add_text', ctx=Load()), args=[Subscript(value=Name(id='json_response', ctx=Load()), slice=Constant(value='response'), ctx=Load())], keywords=[]))], orelse=[]), If(test=Call(func=Attribute(value=Name(id='json_response', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='done'), Constant(value=False)], keywords=[]), body=[Break()], orelse=[])], orelse=[])], orelse=[])], orelse=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error: Received status code '), FormattedValue(value=Attribute(value=Name(id='response', ctx=Load()), attr='status_code', ctx=Load()), conversion=-1)])], keywords=[]))])])], handlers=[ExceptHandler(type=Attribute(value=Name(id='requests', ctx=Load()), attr='RequestException', ctx=Load()), name='e', body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='Error connecting to Ollama: '), FormattedValue(value=Name(id='e', ctx=Load()), conversion=-1)])], keywords=[]))])], orelse=[], finalbody=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='printer', ctx=Load()), attr='stop', ctx=Load()), args=[], keywords=[]))])], decorator_list=[])",
                            "docstring": null
                        }
                    ]
                }
            ],
            "imports": [
                "Import(names=[alias(name='requests')])",
                "Import(names=[alias(name='json')])",
                "ImportFrom(module='mprint', names=[alias(name='WordAwareStreamPrinter')], level=1)"
            ],
            "content": "import requests\nimport json\nfrom .mprint import WordAwareStreamPrinter\n\n\nclass OllamaClient:\n    def __init__(self, base_url=\"http://localhost:11434\", model=\"llama3.1:latest\"):\n        self.base_url = base_url\n        self.model = model\n        self.printer = WordAwareStreamPrinter(max_line_width=80)\n\n    def process_response(self, prompt):\n        url = f\"{self.base_url}/api/generate\"\n        headers = {\"Content-Type\": \"application/json\"}\n        data = {\"model\": self.model, \"prompt\": prompt}\n\n        try:\n            with requests.post(\n                url, headers=headers, json=data, stream=True\n            ) as response:\n                if response.status_code == 200:\n                    for line in response.iter_lines():\n                        if line:\n                            json_response = json.loads(line)\n                            if \"response\" in json_response:\n                                self.printer.add_text(json_response[\"response\"])\n                            if json_response.get(\"done\", False):\n                                break\n                else:\n                    print(f\"Error: Received status code {response.status_code}\")\n        except requests.RequestException as e:\n            print(f\"Error connecting to Ollama: {e}\")\n        finally:\n            self.printer.stop()\n\n\n# We'll no longer need this function as we'll create the client in main.py\n# def generate_and_print_response(prompt, model=\"llama3.1:latest\"):\n#     client = OllamaClient()\n#     client.generate_and_print(prompt, model)\n\n# For testing purposes\nif __name__ == \"__main__\":\n    client = OllamaClient()\n    client.generate_and_print(\"Hello, world!\")\n"
        },
        {
            "path": "/Users/bard/Code/AITools/modules/utils/mprint.py",
            "type": "python",
            "size": 1677,
            "docstring": null,
            "functions": [
                {
                    "name": "__init__",
                    "signature": "FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='max_line_width')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=80)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Store())], value=Call(func=Attribute(value=Name(id='queue', ctx=Load()), attr='Queue', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max_line_width', ctx=Store())], value=Name(id='max_line_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Event', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Thread', ctx=Load()), args=[], keywords=[keyword(arg='target', value=Attribute(value=Name(id='self', ctx=Load()), attr='_consumer', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                    "docstring": null
                },
                {
                    "name": "add_text",
                    "signature": "FunctionDef(name='add_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add text to the queue.')), For(target=Name(id='char', ctx=Store()), iter=Name(id='text', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Load()), attr='put', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
                    "docstring": "Add text to the queue."
                },
                {
                    "name": "stop",
                    "signature": "FunctionDef(name='stop', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Stop the consumer thread.')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Load()), attr='set', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                    "docstring": "Stop the consumer thread."
                },
                {
                    "name": "_consumer",
                    "signature": "FunctionDef(name='_consumer', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value='')), While(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Load()), attr='is_set', ctx=Load()), args=[], keywords=[])), body=[Try(body=[Assign(targets=[Name(id='char', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Constant(value=0.1))])), AugAssign(target=Name(id='current_word', ctx=Store()), op=Add(), value=Name(id='char', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='char', ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='current_line', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='current_word', ctx=Load())], keywords=[])), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='max_line_width', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='current_line', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Name(id='current_word', ctx=Load()))], orelse=[AugAssign(target=Name(id='current_line', ctx=Store()), op=Add(), value=Name(id='current_word', ctx=Load()))]), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[]), If(test=Compare(left=Name(id='char', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\\n')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='current_line', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[])], handlers=[ExceptHandler(type=Attribute(value=Name(id='queue', ctx=Load()), attr='Empty', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Name(id='current_line', ctx=Load()), Name(id='current_word', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Name(id='current_line', ctx=Load()), op=Add(), right=Name(id='current_word', ctx=Load()))], keywords=[keyword(arg='end', value=Constant(value='')), keyword(arg='flush', value=Constant(value=True))])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[])])], orelse=[], finalbody=[])], orelse=[]), If(test=BoolOp(op=Or(), values=[Name(id='current_line', ctx=Load()), Name(id='current_word', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Name(id='current_line', ctx=Load()), op=Add(), right=Name(id='current_word', ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[])",
                    "docstring": null
                }
            ],
            "classes": [
                {
                    "name": "WordAwareStreamPrinter",
                    "docstring": null,
                    "methods": [
                        {
                            "name": "__init__",
                            "signature": "FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='max_line_width')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=80)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Store())], value=Call(func=Attribute(value=Name(id='queue', ctx=Load()), attr='Queue', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='max_line_width', ctx=Store())], value=Name(id='max_line_width', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Event', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Store())], value=Call(func=Attribute(value=Name(id='threading', ctx=Load()), attr='Thread', ctx=Load()), args=[], keywords=[keyword(arg='target', value=Attribute(value=Name(id='self', ctx=Load()), attr='_consumer', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Load()), attr='start', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                            "docstring": null
                        },
                        {
                            "name": "add_text",
                            "signature": "FunctionDef(name='add_text', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='text')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add text to the queue.')), For(target=Name(id='char', ctx=Store()), iter=Name(id='text', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Load()), attr='put', ctx=Load()), args=[Name(id='char', ctx=Load())], keywords=[]))], orelse=[])], decorator_list=[])",
                            "docstring": "Add text to the queue."
                        },
                        {
                            "name": "stop",
                            "signature": "FunctionDef(name='stop', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Stop the consumer thread.')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Load()), attr='set', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='consumer_thread', ctx=Load()), attr='join', ctx=Load()), args=[], keywords=[]))], decorator_list=[])",
                            "docstring": "Stop the consumer thread."
                        },
                        {
                            "name": "_consumer",
                            "signature": "FunctionDef(name='_consumer', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value='')), While(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='stop_event', ctx=Load()), attr='is_set', ctx=Load()), args=[], keywords=[])), body=[Try(body=[Assign(targets=[Name(id='char', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='queue', ctx=Load()), attr='get', ctx=Load()), args=[], keywords=[keyword(arg='timeout', value=Constant(value=0.1))])), AugAssign(target=Name(id='current_word', ctx=Store()), op=Add(), value=Name(id='char', ctx=Load())), If(test=Call(func=Attribute(value=Name(id='char', ctx=Load()), attr='isspace', ctx=Load()), args=[], keywords=[]), body=[If(test=Compare(left=BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='current_line', ctx=Load())], keywords=[]), op=Add(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='current_word', ctx=Load())], keywords=[])), ops=[Gt()], comparators=[Attribute(value=Name(id='self', ctx=Load()), attr='max_line_width', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='current_line', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Name(id='current_word', ctx=Load()))], orelse=[AugAssign(target=Name(id='current_line', ctx=Store()), op=Add(), value=Name(id='current_word', ctx=Load()))]), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[]), If(test=Compare(left=Name(id='char', ctx=Load()), ops=[Eq()], comparators=[Constant(value='\\n')]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Name(id='current_line', ctx=Load()), attr='rstrip', ctx=Load()), args=[], keywords=[])], keywords=[])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[])], handlers=[ExceptHandler(type=Attribute(value=Name(id='queue', ctx=Load()), attr='Empty', ctx=Load()), body=[If(test=BoolOp(op=Or(), values=[Name(id='current_line', ctx=Load()), Name(id='current_word', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Name(id='current_line', ctx=Load()), op=Add(), right=Name(id='current_word', ctx=Load()))], keywords=[keyword(arg='end', value=Constant(value='')), keyword(arg='flush', value=Constant(value=True))])), Assign(targets=[Name(id='current_line', ctx=Store())], value=Constant(value='')), Assign(targets=[Name(id='current_word', ctx=Store())], value=Constant(value=''))], orelse=[])])], orelse=[], finalbody=[])], orelse=[]), If(test=BoolOp(op=Or(), values=[Name(id='current_line', ctx=Load()), Name(id='current_word', ctx=Load())]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[BinOp(left=Name(id='current_line', ctx=Load()), op=Add(), right=Name(id='current_word', ctx=Load()))], keywords=[]))], orelse=[])], decorator_list=[])",
                            "docstring": null
                        }
                    ]
                }
            ],
            "imports": [
                "Import(names=[alias(name='queue')])",
                "Import(names=[alias(name='threading')])"
            ],
            "content": "import queue\nimport threading\n\n\nclass WordAwareStreamPrinter:\n    def __init__(self, max_line_width=80):\n        self.queue = queue.Queue()\n        self.max_line_width = max_line_width\n        self.stop_event = threading.Event()\n        self.consumer_thread = threading.Thread(target=self._consumer)\n        self.consumer_thread.start()\n\n    def add_text(self, text):\n        \"\"\"Add text to the queue.\"\"\"\n        for char in text:\n            self.queue.put(char)\n\n    def stop(self):\n        \"\"\"Stop the consumer thread.\"\"\"\n        self.stop_event.set()\n        self.consumer_thread.join()\n\n    def _consumer(self):\n        current_line = \"\"\n        current_word = \"\"\n\n        while not self.stop_event.is_set():\n            try:\n                char = self.queue.get(timeout=0.1)\n                current_word += char\n\n                if char.isspace():\n                    if len(current_line) + len(current_word) > self.max_line_width:\n                        print(current_line.rstrip())\n                        current_line = current_word\n                    else:\n                        current_line += current_word\n                    current_word = \"\"\n\n                if char == \"\\n\":\n                    print(current_line.rstrip())\n                    current_line = \"\"\n                    current_word = \"\"\n\n            except queue.Empty:\n                if current_line or current_word:\n                    print(current_line + current_word, end=\"\", flush=True)\n                    current_line = \"\"\n                    current_word = \"\"\n\n        # Print any remaining text\n        if current_line or current_word:\n            print(current_line + current_word)\n"
        },
        {
            "path": "/Users/bard/Code/AITools/modules/models/__init__.py",
            "type": "python",
            "size": 0,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [],
            "content": ""
        },
        {
            "path": "/Users/bard/Code/AITools/modules/data/__init__.py",
            "type": "python",
            "size": 0,
            "docstring": null,
            "functions": [],
            "classes": [],
            "imports": [],
            "content": ""
        }
    ],
    "version_info": {
        "python": "3.10.14 | packaged by conda-forge | (main, Mar 20 2024, 12:51:49) [Clang 16.0.6 ]",
        "codemapper": "0.1.0",
        "dependencies": {
            "authlib": "1.3.1",
            "brotli": "1.0.9",
            "flaml": "2.1.1",
            "faker": "22.5.1",
            "fastapi-sqlalchemy": "0.2.1",
            "instructorembedding": "1.0.1",
            "mako": "1.2.4",
            "markdown": "3.6",
            "markupsafe": "2.1.5",
            "pygetwindow": "0.0.9",
            "pymsgbox": "1.0.9",
            "pynacl": "1.5.0",
            "pypika": "0.48.9",
            "pyrect": "0.2.0",
            "pyscreeze": "0.1.30",
            "pysocks": "1.7.1",
            "pympler": "1.1",
            "rust": "1.3.1",
            "sqlalchemy-utils": "0.41.2",
            "send2trash": "1.8.2",
            "xlsxwriter": "3.1.9",
            "absl-py": "2.1.0",
            "anyio": "4.4.0",
            "appdirs": "1.4.4",
            "archspec": "0.2.3",
            "astunparse": "1.6.3",
            "attrs": "24.2.0",
            "blinker": "1.8.2",
            "boltons": "24.0.0",
            "cachetools": "5.4.0",
            "certifi": "2024.2.2",
            "cffi": "1.16.0",
            "charset-normalizer": "3.3.2",
            "click": "8.1.7",
            "codemapper": "0.1.0",
            "colorama": "0.4.6",
            "conda": "24.3.0",
            "conda-libmamba-solver": "23.12.0",
            "conda-package-handling": "2.2.0",
            "conda-package-streaming": "0.10.0",
            "cryptography": "42.0.5",
            "distro": "1.9.0",
            "emoji": "2.12.1",
            "en-core-web-sm": "3.7.1",
            "en-core-web-trf": "3.7.3",
            "entrypoints": "0.4",
            "environs": "9.5.0",
            "et-xmlfile": "1.1.0",
            "exceptiongroup": "1.1.1",
            "executing": "2.0.1",
            "fabric": "3.2.2",
            "fastapi-jwt-auth": "0.5.0",
            "fastjsonschema": "2.19.1",
            "favicon": "0.7.0",
            "feedfinder2": "0.0.4",
            "ferret": "1.0.1",
            "ffmpy": "0.3.1",
            "filetype": "1.2.0",
            "flatbuffers": "23.5.26",
            "fonttools": "4.47.0",
            "fqdn": "1.5.1",
            "frozendict": "2.4.2",
            "frozenlist": "1.3.3",
            "fschat": "0.2.34",
            "fsspec": "2023.12.2",
            "gast": "0.4.0",
            "gitdb": "4.0.11",
            "google-ai-generativelanguage": "0.6.4",
            "google-api-core": "2.11.0",
            "google-api-python-client": "2.88.0",
            "google-auth": "2.18.0",
            "google-auth-httplib2": "0.1.0",
            "google-auth-oauthlib": "1.0.0",
            "google-generativeai": "0.5.4",
            "google-pasta": "0.2.0",
            "google-search-results": "2.4.2",
            "google-serp-api": "1.0.3",
            "googleapis-common-protos": "1.56.4",
            "gpt4all": "2.0.2",
            "gradio-client": "0.1.2",
            "greenlet": "2.0.2",
            "grpcio": "1.65.4",
            "grpcio-status": "1.60.0",
            "grpcio-tools": "1.60.0",
            "h11": "0.14.0",
            "h2": "4.1.0",
            "h5py": "3.9.0",
            "halo": "0.0.31",
            "hjson": "3.1.0",
            "hnswlib": "0.8.0",
            "hpack": "4.0.0",
            "htbuilder": "0.6.2",
            "httpcore": "1.0.5",
            "httplib2": "0.22.0",
            "httptools": "0.5.0",
            "httpx": "0.25.2",
            "httpx-sse": "0.4.0",
            "humanfriendly": "10.0",
            "hyperframe": "6.0.1",
            "identify": "2.5.33",
            "idna": "3.6",
            "importlib-metadata": "8.2.0",
            "importlib-resources": "5.12.0",
            "iniconfig": "2.0.0",
            "ipywidgets": "8.1.3",
            "isoduration": "20.11.0",
            "itsdangerous": "2.1.2",
            "jaraco.classes": "3.4.0",
            "jaraco.context": "5.3.0",
            "jaraco.functools": "4.0.2",
            "jedi": "0.19.1",
            "jieba3k": "0.35.1",
            "jinja2": "3.1.4",
            "jira": "3.5.0",
            "jiter": "0.5.0",
            "jmespath": "1.0.1",
            "joblib": "1.2.0",
            "json5": "0.9.14",
            "jsonmerge": "1.9.0",
            "jsonpatch": "1.33",
            "jsonpointer": "2.1",
            "jsonschema": "4.21.1",
            "jsonschema-specifications": "2023.12.1",
            "jupyter-client": "8.6.0",
            "jupyter-core": "5.7.1",
            "jupyter-events": "0.9.0",
            "jupyter-lsp": "2.2.2",
            "jupyter-server": "2.12.5",
            "jupyter-server-terminals": "0.5.2",
            "jupyterlab": "4.2.2",
            "jupyterlab-pygments": "0.3.0",
            "jupyterlab-server": "2.27.2",
            "jupyterlab-widgets": "3.0.11",
            "keyring": "25.2.1",
            "kiwisolver": "1.4.5",
            "kombu": "5.2.4",
            "kubernetes": "30.1.0",
            "lancedb": "0.3.6",
            "langchain-chroma": "0.1.1",
            "langchain-cli": "0.0.19",
            "langchain-experimental": "0.0.49",
            "langchain-google-genai": "1.0.4",
            "langchain-huggingface": "0.0.3",
            "langchain-text-splitters": "0.0.2",
            "langcodes": "3.4.0",
            "langgraph": "0.0.49",
            "langserve": "0.0.36",
            "langsmith": "0.1.76",
            "language-data": "1.2.0",
            "libclang": "16.0.6",
            "libmambapy": "1.5.3",
            "linkify-it-py": "2.0.2",
            "litellm": "1.14.2",
            "llama-cloud": "0.0.13",
            "llama-index-agent-openai": "0.2.9",
            "llama-index-cli": "0.1.13",
            "llama-index-core": "0.10.63",
            "llama-index-embeddings-azure-openai": "0.1.11",
            "llama-index-embeddings-huggingface": "0.2.2",
            "llama-index-embeddings-openai": "0.1.11",
            "llama-index-indices-managed-llama-cloud": "0.2.7",
            "llama-index-legacy": "0.9.48",
            "llama-index-llms-azure-openai": "0.1.10",
            "llama-index-llms-openai": "0.1.29",
            "llama-index-multi-modal-llms-openai": "0.1.9",
            "llama-index-program-openai": "0.1.7",
            "llama-index-question-gen-openai": "0.1.3",
            "llama-index-readers-file": "0.1.32",
            "llama-index-readers-llama-parse": "0.1.6",
            "llama-parse": "0.4.9",
            "llamaapi": "0.1.36",
            "log-symbols": "0.0.14",
            "loguru": "0.7.0",
            "lz4": "4.3.2",
            "mamba": "1.5.3",
            "marisa-trie": "1.2.0",
            "markdown2": "2.4.12",
            "markdown-it-py": "2.2.0",
            "markdownlit": "0.0.7",
            "marshmallow": "3.19.0",
            "marshmallow-enum": "1.5.1",
            "matplotlib-inline": "0.1.6",
            "mccabe": "0.7.0",
            "mdit-py-plugins": "0.3.3",
            "mdurl": "0.1.2",
            "menuinst": "2.0.2",
            "milvus-lite": "2.4.7",
            "minijinja": "2.0.1",
            "mistune": "3.0.2",
            "ml-dtypes": "0.4.0",
            "mmh3": "4.1.0",
            "monotonic": "1.6",
            "more-itertools": "10.1.0",
            "mpmath": "1.3.0",
            "msal": "1.30.0",
            "msal-extensions": "1.2.0",
            "murmurhash": "1.0.10",
            "mypy-extensions": "1.0.0",
            "nbclient": "0.9.0",
            "nbconvert": "7.14.2",
            "nbformat": "5.9.2",
            "neovim": "0.3.1",
            "nervaluate": "0.2.0",
            "nest-asyncio": "1.6.0",
            "nh3": "0.2.15",
            "ninja": "1.11.1.1",
            "nodeenv": "1.8.0",
            "notebook-shim": "0.2.3",
            "numba": "0.58.1",
            "numexpr": "2.8.4",
            "oauth2client": "4.1.3",
            "oauthlib": "3.2.2",
            "olefile": "0.47",
            "ollama": "0.2.1",
            "onnxruntime": "1.15.1",
            "openapi-schema-pydantic": "1.2.4",
            "openpyxl": "3.1.2",
            "opentelemetry-api": "1.25.0",
            "opentelemetry-exporter-otlp-proto-common": "1.25.0",
            "opentelemetry-exporter-otlp-proto-grpc": "1.25.0",
            "opentelemetry-instrumentation": "0.46b0",
            "opentelemetry-instrumentation-asgi": "0.46b0",
            "opentelemetry-instrumentation-fastapi": "0.46b0",
            "opentelemetry-proto": "1.25.0",
            "opentelemetry-sdk": "1.25.0",
            "opentelemetry-semantic-conventions": "0.46b0",
            "opentelemetry-util-http": "0.46b0",
            "opt-einsum": "3.3.0",
            "overrides": "7.4.0",
            "packaging": "24.0",
            "pandocfilters": "1.5.1",
            "parse": "1.19.0",
            "pathspec": "0.12.1",
            "pdf2image": "1.16.3",
            "peft": "0.4.0",
            "pep8": "1.7.1",
            "php": "1.2.1",
            "pinecone-client": "2.2.1",
            "pip": "24.0",
            "pkginfo": "1.10.0",
            "platformdirs": "3.10.0",
            "pluggy": "1.0.0",
            "portalocker": "2.8.2",
            "posthog": "3.0.1",
            "pre-commit": "3.3.3",
            "preshed": "3.0.9",
            "prettytable": "3.10.2",
            "prometheus-client": "0.19.0",
            "proto-plus": "1.23.0",
            "protobuf": "3.20.3",
            "psutil": "5.9.7",
            "pulsar-client": "3.2.0",
            "pure-eval": "0.2.2",
            "py": "1.11.0",
            "pyopenssl": "24.0.0",
            "py-cpuinfo": "9.0.0",
            "pyaml": "23.12.0",
            "pyarrow": "15.0.0",
            "pyasn1": "0.6.0",
            "pyasn1-modules": "0.4.0",
            "pyautogen": "0.2.2",
            "pycocotools": "2.0.7",
            "pycosat": "0.6.6",
            "pycparser": "2.21",
            "pycryptodome": "3.18.0",
            "pydantic": "1.10.17",
            "pydantic-core": "2.20.1",
            "pydantic-settings": "2.4.0",
            "pydeck": "0.8.1b0",
            "pyee": "8.2.2",
            "pygments": "2.18.0",
            "pylance": "0.8.21",
            "pymdown-extensions": "10.7",
            "pymemgpt": "0.3.22",
            "pymilvus": "2.4.3",
            "pynvim": "0.5.0",
            "pyobjc": "10.1",
            "pyobjc-core": "10.1",
            "pyobjc-framework-avfoundation": "10.1",
            "pyobjc-framework-avkit": "10.1",
            "pyobjc-framework-avrouting": "10.1",
            "pyobjc-framework-accessibility": "10.1",
            "pyobjc-framework-accounts": "10.1",
            "pyobjc-framework-adservices": "10.1",
            "pyobjc-framework-adsupport": "10.1",
            "pyobjc-framework-addressbook": "10.1",
            "pyobjc-framework-apptrackingtransparency": "10.1",
            "pyobjc-framework-applescriptkit": "10.1",
            "pyobjc-framework-applescriptobjc": "10.1",
            "pyobjc-framework-applicationservices": "10.1",
            "pyobjc-framework-audiovideobridging": "10.1",
            "pyobjc-framework-authenticationservices": "10.1",
            "pyobjc-framework-automaticassessmentconfiguration": "10.1",
            "pyobjc-framework-automator": "10.1",
            "pyobjc-framework-backgroundassets": "10.1",
            "pyobjc-framework-businesschat": "10.1",
            "pyobjc-framework-cfnetwork": "10.1",
            "pyobjc-framework-calendarstore": "10.1",
            "pyobjc-framework-callkit": "10.1",
            "pyobjc-framework-cinematic": "10.1",
            "pyobjc-framework-classkit": "10.1",
            "pyobjc-framework-cloudkit": "10.1",
            "pyobjc-framework-cocoa": "10.1",
            "pyobjc-framework-collaboration": "10.1",
            "pyobjc-framework-colorsync": "10.1",
            "pyobjc-framework-contacts": "10.1",
            "pyobjc-framework-contactsui": "10.1",
            "pyobjc-framework-coreaudio": "10.1",
            "pyobjc-framework-coreaudiokit": "10.1",
            "pyobjc-framework-corebluetooth": "10.1",
            "pyobjc-framework-coredata": "10.1",
            "pyobjc-framework-corehaptics": "10.1",
            "pyobjc-framework-corelocation": "10.1",
            "pyobjc-framework-coremidi": "10.1",
            "pyobjc-framework-coreml": "10.1",
            "pyobjc-framework-coremedia": "10.1",
            "pyobjc-framework-coremediaio": "10.1",
            "pyobjc-framework-coremotion": "10.1",
            "pyobjc-framework-coreservices": "10.1",
            "pyobjc-framework-corespotlight": "10.1",
            "pyobjc-framework-coretext": "10.1",
            "pyobjc-framework-corewlan": "10.1",
            "pyobjc-framework-cryptotokenkit": "10.1",
            "pyobjc-framework-dvdplayback": "10.1",
            "pyobjc-framework-datadetection": "10.1",
            "pyobjc-framework-devicecheck": "10.1",
            "pyobjc-framework-dictionaryservices": "10.1",
            "pyobjc-framework-discrecording": "10.1",
            "pyobjc-framework-discrecordingui": "10.1",
            "pyobjc-framework-diskarbitration": "10.1",
            "pyobjc-framework-eventkit": "10.1",
            "pyobjc-framework-exceptionhandling": "10.1",
            "pyobjc-framework-executionpolicy": "10.1",
            "pyobjc-framework-extensionkit": "10.1",
            "pyobjc-framework-externalaccessory": "10.1",
            "pyobjc-framework-fsevents": "10.1",
            "pyobjc-framework-fileprovider": "10.1",
            "pyobjc-framework-fileproviderui": "10.1",
            "pyobjc-framework-findersync": "10.1",
            "pyobjc-framework-gamecenter": "10.1",
            "pyobjc-framework-gamecontroller": "10.1",
            "pyobjc-framework-gamekit": "10.1",
            "pyobjc-framework-gameplaykit": "10.1",
            "pyobjc-framework-healthkit": "10.1",
            "pyobjc-framework-iobluetooth": "10.1",
            "pyobjc-framework-iobluetoothui": "10.1",
            "pyobjc-framework-iosurface": "10.1",
            "pyobjc-framework-imagecapturecore": "10.1",
            "pyobjc-framework-inputmethodkit": "10.1",
            "pyobjc-framework-installerplugins": "10.1",
            "pyobjc-framework-instantmessage": "10.1",
            "pyobjc-framework-intents": "10.1",
            "pyobjc-framework-intentsui": "10.1",
            "pyobjc-framework-kernelmanagement": "10.1",
            "pyobjc-framework-latentsemanticmapping": "10.1",
            "pyobjc-framework-launchservices": "10.1",
            "pyobjc-framework-linkpresentation": "10.1",
            "pyobjc-framework-localauthentication": "10.1",
            "pyobjc-framework-localauthenticationembeddedui": "10.1",
            "pyobjc-framework-mlcompute": "10.1",
            "pyobjc-framework-mailkit": "10.1",
            "pyobjc-framework-mapkit": "10.1",
            "pyobjc-framework-mediaaccessibility": "10.1",
            "pyobjc-framework-medialibrary": "10.1",
            "pyobjc-framework-mediaplayer": "10.1",
            "pyobjc-framework-mediatoolbox": "10.1",
            "pyobjc-framework-metal": "10.1",
            "pyobjc-framework-metalfx": "10.1",
            "pyobjc-framework-metalkit": "10.1",
            "pyobjc-framework-metalperformanceshaders": "10.1",
            "pyobjc-framework-metalperformanceshadersgraph": "10.1",
            "pyobjc-framework-metrickit": "10.1",
            "pyobjc-framework-modelio": "10.1",
            "pyobjc-framework-multipeerconnectivity": "10.1",
            "pyobjc-framework-naturallanguage": "10.1",
            "pyobjc-framework-netfs": "10.1",
            "pyobjc-framework-network": "10.1",
            "pyobjc-framework-networkextension": "10.1",
            "pyobjc-framework-notificationcenter": "10.1",
            "pyobjc-framework-osakit": "10.1",
            "pyobjc-framework-oslog": "10.1",
            "pyobjc-framework-opendirectory": "10.1",
            "pyobjc-framework-phase": "10.1",
            "pyobjc-framework-passkit": "10.1",
            "pyobjc-framework-pencilkit": "10.1",
            "pyobjc-framework-photos": "10.1",
            "pyobjc-framework-photosui": "10.1",
            "pyobjc-framework-preferencepanes": "10.1",
            "pyobjc-framework-pushkit": "10.1",
            "pyobjc-framework-quartz": "10.1",
            "pyobjc-framework-quicklookthumbnailing": "10.1",
            "pyobjc-framework-replaykit": "10.1",
            "pyobjc-framework-safariservices": "10.1",
            "pyobjc-framework-safetykit": "10.1",
            "pyobjc-framework-scenekit": "10.1",
            "pyobjc-framework-screencapturekit": "10.1",
            "pyobjc-framework-screensaver": "10.1",
            "pyobjc-framework-screentime": "10.1",
            "pyobjc-framework-scriptingbridge": "10.1",
            "pyobjc-framework-searchkit": "10.1",
            "pyobjc-framework-security": "10.1",
            "pyobjc-framework-securityfoundation": "10.1",
            "pyobjc-framework-securityinterface": "10.1",
            "pyobjc-framework-sensitivecontentanalysis": "10.1",
            "pyobjc-framework-servicemanagement": "10.1",
            "pyobjc-framework-sharedwithyou": "10.1",
            "pyobjc-framework-sharedwithyoucore": "10.1",
            "pyobjc-framework-shazamkit": "10.1",
            "pyobjc-framework-social": "10.1",
            "pyobjc-framework-soundanalysis": "10.1",
            "pyobjc-framework-speech": "10.1",
            "pyobjc-framework-spritekit": "10.1",
            "pyobjc-framework-storekit": "10.1",
            "pyobjc-framework-symbols": "10.1",
            "pyobjc-framework-syncservices": "10.1",
            "pyobjc-framework-systemconfiguration": "10.1",
            "pyobjc-framework-systemextensions": "10.1",
            "pyobjc-framework-threadnetwork": "10.1",
            "pyobjc-framework-uniformtypeidentifiers": "10.1",
            "pyobjc-framework-usernotifications": "10.1",
            "pyobjc-framework-usernotificationsui": "10.1",
            "pyobjc-framework-videosubscriberaccount": "10.1",
            "pyobjc-framework-videotoolbox": "10.1",
            "pyobjc-framework-virtualization": "10.1",
            "pyobjc-framework-vision": "10.1",
            "pyobjc-framework-webkit": "10.1",
            "pyobjc-framework-ituneslibrary": "10.1",
            "pyobjc-framework-libdispatch": "10.1",
            "pyobjc-framework-libxpc": "10.1",
            "pypandoc": "1.12",
            "pyparsing": "3.1.1",
            "pyperclip": "1.9.0",
            "pyppeteer": "0.2.5",
            "pyproject-hooks": "1.1.0",
            "pyreadline3": "3.4.1",
            "pyreqwest-impersonate": "0.4.7",
            "pysam": "0.22.1",
            "python-box": "7.2.0",
            "python-dateutil": "2.8.2",
            "python-docx": "1.1.0",
            "python-json-logger": "2.0.7",
            "python-magic": "0.4.27",
            "python-multipart": "0.0.9",
            "python-pptx": "0.6.21",
            "pytweening": "1.2.0",
            "pytz": "2023.4",
            "qdrant-client": "1.2.0",
            "questionary": "2.0.1",
            "ratelimiter": "1.2.0.post0",
            "readme-renderer": "44.0",
            "referencing": "0.32.1",
            "regex": "2023.5.5",
            "replicate": "0.8.4",
            "requests": "2.31.0",
            "requests-file": "1.5.1",
            "requests-oauthlib": "2.0.0",
            "requests-toolbelt": "1.0.0",
            "retry": "0.9.2",
            "rfc3339-validator": "0.1.4",
            "rfc3986": "2.0.0",
            "rfc3986-validator": "0.1.1",
            "rich": "13.7.0",
            "rpds-py": "0.17.1",
            "rq": "1.15.1",
            "rsa": "4.9",
            "ruamel.yaml": "0.17.21",
            "ruamel.yaml.clib": "0.2.8",
            "rubicon-objc": "0.4.9",
            "safetensors": "0.4.3",
            "semantic-version": "2.10.0",
            "semver": "3.0.2",
            "sentence-transformers": "3.0.1",
            "sentencepiece": "0.1.99",
            "sentry-sdk": "1.39.1",
            "setproctitle": "1.3.3",
            "setuptools": "68.2.2",
            "sgmllib3k": "1.0.0",
            "shellingham": "1.5.4",
            "shortuuid": "1.0.11",
            "six": "1.16.0",
            "slack-sdk": "3.21.3",
            "slugify": "0.0.1",
            "smmap": "5.0.1",
            "sniffio": "1.3.0",
            "socksio": "1.0.0",
            "soupsieve": "2.4.1",
            "spacy-curated-transformers": "0.2.2",
            "spacy-legacy": "3.0.12",
            "spacy-loggers": "1.0.5",
            "spinners": "0.0.24",
            "sqlalchemy-json": "0.7.0",
            "sqlmodel": "0.0.16",
            "srsly": "2.4.8",
            "sse-starlette": "1.8.2",
            "st-annotated-text": "4.0.1",
            "stack-data": "0.6.3",
            "stanza": "1.8.2",
            "streamlit-camera-input-live": "0.2.0",
            "streamlit-card": "1.0.0",
            "streamlit-embedcode": "0.1.2",
            "streamlit-extras": "0.3.6",
            "streamlit-faker": "0.0.3",
            "streamlit-image-coordinates": "0.1.6",
            "streamlit-keyup": "0.2.2",
            "streamlit-toggle-switch": "1.0.2",
            "streamlit-vertical-slider": "2.5.5",
            "striprtf": "0.0.26",
            "svgwrite": "1.4.3",
            "tenacity": "8.3.0",
            "tensorboard-data-server": "0.7.1",
            "termcolor": "2.3.0",
            "terminado": "0.18.0",
            "text-unidecode": "1.3",
            "thinc": "8.2.4",
            "threadpoolctl": "3.2.0",
            "timm": "0.6.13",
            "tinycss2": "1.2.1",
            "tinysegmenter": "0.3",
            "tokenizers": "0.19.1",
            "toml": "0.10.2",
            "tomli": "2.0.1",
            "tomlkit": "0.12.3",
            "toolz": "0.12.1",
            "tornado": "6.4",
            "tqdm": "4.66.2",
            "traitlets": "5.14.1",
            "truststore": "0.8.0",
            "tweepy": "4.14.0",
            "typer": "0.9.0",
            "types-python-dateutil": "2.8.19.20240106",
            "typing-extensions": "4.5.0",
            "typing-inspect": "0.8.0",
            "tzdata": "2023.3",
            "tzlocal": "5.2",
            "uc-micro-py": "1.0.2",
            "unstructured": "0.8.1",
            "uri-template": "1.3.0",
            "uritemplate": "4.1.1",
            "urllib3": "1.26.19",
            "uvloop": "0.17.0",
            "validators": "0.21.0",
            "vine": "5.0.0",
            "w3lib": "2.1.1",
            "wasabi": "1.1.3",
            "watchfiles": "0.19.0",
            "wavedrom": "2.0.3.post3",
            "wcwidth": "0.2.13",
            "weasel": "0.4.1",
            "weaviate-client": "3.19.0",
            "webcolors": "1.13",
            "websockets": "8.1",
            "werkzeug": "3.0.1",
            "wheel": "0.43.0",
            "widgetsnbextension": "4.0.11",
            "wikipedia": "1.4.0",
            "wrapt": "1.14.1",
            "wxpython": "4.2.1",
            "xlrd": "2.0.1",
            "zipp": "3.15.0",
            "zstandard": "0.22.0"
        }
    }
}